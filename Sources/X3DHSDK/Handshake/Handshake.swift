import Foundation
import CryptoKit

/// Responsible for initiating the X3DH handshake with a recipient.
/// Performs multiple Diffie-Hellman operations to derive a shared session key.
internal struct HandshakeInitiator {
    private let identityKey: PrivateKey
    private let ephemeralKey: PrivateKey

    /// Initializes a new handshake initiator with an identity key and an optional ephemeral key.
    ///
    /// - Parameters:
    ///   - identityKey: Your long-term identity key.
    ///   - ephemeralKey: A fresh ephemeral key (generated by default).
    public init(identityKey: PrivateKey, ephemeralKey: PrivateKey = PrivateKey()) {
        self.identityKey = identityKey
        self.ephemeralKey = ephemeralKey
    }

    /// Performs the X3DH handshake using the recipient's identity and signed prekey.
    ///
    /// - Parameters:
    ///   - recipientIdentityKey: Recipient's long-term identity public key.
    ///   - recipientSignedPreKey: Recipient's signed prekey.
    /// - Returns: A symmetric key derived from the shared secrets.
    /// - Throws: `X3DHError.keyAgreementFailed` if key agreement fails.
    public func performHandshake(recipientIdentityKey: PublicKey, recipientSignedPreKey: PublicKey) throws -> SymmetricKey {
        do {
            let dh1 = try identityKey.sharedSecret(with: recipientSignedPreKey)
            let dh2 = try ephemeralKey.sharedSecret(with: recipientIdentityKey)
            let dh3 = try ephemeralKey.sharedSecret(with: recipientSignedPreKey)

            let combinedSecrets = dh1.ssData() + dh2.ssData() + dh3.ssData()

            return KeyDerivation.deriveSymmetricKey(data: combinedSecrets)
        } catch {
            throw X3DHError.keyAgreementFailed
        }
    }

    /// Returns the ephemeral public key to be sent along with the message.
    public func ephemeralPublicKey() -> PublicKey {
        return ephemeralKey.publicKey()
    }
}

/// Responsible for responding to a handshake initiated using the X3DH protocol.
/// Reconstructs the shared session key using the initiatorâ€™s public keys.
internal struct HandshakeResponder {
    private let identityKey: PrivateKey
    private let signedPreKey: PrivateKey

    /// Initializes a new responder with their identity and signed prekey.
    ///
    /// - Parameters:
    ///   - identityKey: Your long-term identity private key.
    ///   - signedPreKey: Your signed prekey used in the handshake.
    public init(identityKey: PrivateKey, signedPreKey: PrivateKey) {
        self.identityKey = identityKey
        self.signedPreKey = signedPreKey
    }

    /// Performs the handshake with the initiator's identity and ephemeral public keys.
    ///
    /// - Parameters:
    ///   - senderIdentityKey: Sender's identity public key.
    ///   - senderEphemeralKey: Sender's ephemeral public key.
    /// - Returns: A symmetric key derived from the shared secrets.
    /// - Throws: `X3DHError.keyAgreementFailed` if key agreement fails.
    public func performHandshake(senderIdentityKey: PublicKey, senderEphemeralKey: PublicKey) throws -> SymmetricKey {
        do {
            let dh1 = try signedPreKey.sharedSecret(with: senderIdentityKey)
            let dh2 = try identityKey.sharedSecret(with: senderEphemeralKey)
            let dh3 = try signedPreKey.sharedSecret(with: senderEphemeralKey)

            let combinedSecrets = dh1.ssData() + dh2.ssData() + dh3.ssData()

            return KeyDerivation.deriveSymmetricKey(data: combinedSecrets)
        } catch {
            throw X3DHError.keyAgreementFailed
        }
    }
}

/// Internal helper extension to convert a `SharedSecret` to raw `Data` via HKDF.
internal extension SharedSecret {
    /// Derives 32-byte key material from the shared secret using HKDF.
    func ssData() -> Data {
        self.hkdfDerivedSymmetricKey(
            using: SHA256.self,
            salt: Data(),
            sharedInfo: Data(),
            outputByteCount: 32
        ).withUnsafeBytes { Data($0) }
    }
}
